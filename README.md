# [포트폴리오 게시판 프로젝트]

## 게시판 프로젝트를 선택한 이유

게시판 서비스를 만드는 것은 네트워크 프로그래밍의 Hello World 라고 할 수 있는 아주 기초적인 서비스입니다.<br>
데이터베이스를 배우고, 웹 개발을 배운 상태에서 기본적인 CRUD(Create, Read, Update, Delete) 만으로 구축이 가능한 가장 기본적인 형태의 서비스로,<br>

게시판 서비스에<br>
결제 기능을 붙이면 쇼핑몰이 되고,<br>
복잡한 상태값 처리를 추가하면 예약 서비스가 되거나 경영 지원 시스템이 되는 등<br>

백엔드 개발자에게 필요한 데이터를 다루는 방식과 실력을 가능하기 위한
필요 요소만을 심플하게 보여주는 좋은 예시이기 때문이며,<br>

평가자의 입장에서는 독특한 설계나 복잡한 알고리즘이 제외된 순수한 개발 능력과 방식을 알 수 있기에 빠르게 실력을 평가할 수 있기 때문이라 생각합니다.<br>

이러한 이유로 게시판 서비스를 포트폴리오 프로젝트로 선택하였습니다.

## 게시판 하나를 위해 어디까지 할 수 있을까?

게시판 서비스는 무척이나 단순한 서비스입니다.<br>
게시글을 저장하는 용도의 데이터베이스 테이블을 하나 만들고, 이곳에 CRUD 를 수행하는 API 만을 추가해도 게시판이라는 필요 최소한의 형태가 갖춰진 것이라고 말 할 수 있습니다.<br>

신입 개발자의 경우는 올바른 프로그래밍 지식과 기본적인 개발 능력을 갖추고 있는지와 코드에서 묻어나오는 코딩 습관 등을 파악하기 위해 기능 구현만을 고려하여도 될 것이지만,<br>

경력 개발자의 경우는 그에 더하여 해당 경력에 걸맞는 좋은 샘플 프로젝트가 어떤 것인지를 스스로 생각하는 사고력을 보여줘야만 할 것입니다.<br>

실제 개발 경험상으로 체득한 경험의 지혜와, 지속적인 공부를 통하여 얻은 학문의 지식을 결합하여,<br>
게시판 프로젝트를 하나 만들 때에 어디까지 고려할 수 있고,<br>
개발 실력을 어떻게 해야 최대한 구체적이고 인상적으로 표현할 수 있을 지에 대해 고민하였습니다.<br>

이러한 고민의 결과물로서,<br>
본 프로젝트를 평가하실 때 도움이 될 수 있도록,<br>
제가 고려했던 부분들에 대해 정리하여 설명드리겠습니다.

### 먼저 코드 외적인 부분에서의 고려 사항입니다.

1. 멀티 모듈 MSA 구조 :<br>
   게시판과 인증/인가 기능과 같이, 서로 다르지만 분명히 연관되는 기능을 구현하였을 때,<br>
   프로젝트 책임자의 관점에서 유지 보수 및 기능 추가에 대한 코스트를 낮추어 소프트웨어 공학적 목표를 달성할 수 있도록,<br>
   서로 다른 두 도메인을 MSA 개념으로 나누는 방식을 사용하였습니다.<br><br>
   본 프로젝트에서 보시는 바와 같이 각 마이크로 서비스는 모듈 단위로 나뉘어져 있고,<br>
   각 모듈은 서로 다른 포트번호를 점유하도록 설계하여 결합성을 약화 시켜 독립성을 재고하였습니다.<br>
   이러한 아키텍쳐 측면에서의 처리는 추후 문제가 발생하는 위치에 대한 디버깅을 용이하게 하고,<br>
   서로 다른 코딩 스타일을 가진 숙련된 개발자들간의 독립성을 보장하며,<br>
   코드 재활용 및 대체가 무척이나 용이하게 해주는 장점이 있습니다.<br><br>
   ![화면 캡처 2025-01-22 120750](https://github.com/user-attachments/assets/f15680a0-bfd8-4929-a553-2960dd63470f)<br>
   ![화면 캡처 2025-01-22 120833](https://github.com/user-attachments/assets/4717369d-11d5-4937-a50e-4d8605adbbe6)<br><br>
   아래 도표는 인증/인가 도메인과 게시판 도메인을 MSA 에 맞게 분리했을 때의 구조를 보여줍니다.<br><br>
   ![화면 캡처 2025-01-26 195530](https://github.com/user-attachments/assets/ddb7aa70-3e5b-433c-9693-f34bbb84b07b)<br><br>

2. 효율적인 MSA 구축 및 관리를 위한 Spring Cloud 사용 :<br>
   MSA 를 구축하기 위한 도구로 Spring Cloud 라이브러리를 사용하였습니다.<br><br>
   cloud-eureka 모듈은, auth 나 board 와 같은 마이크로 서비스를 저장하는 역할을 합니다.<br>
   MSA 에서 저금통과 같은 역할을 하며, 모든 마이크로 서비스는 이곳에 모이므로 간단히 상태를 파악하거나, 다른 서비스에서 이러한 정보를 응용할 수 있습니다.<br><br>
   cloud-gateway 모듈은 클라이언트에게 요청을 받으면, eureka 서버에 등록된 마이크로 서비스를 탐색하고 클라이언트가 요청한 적절한 기능을 가진 마이크로 서비스의 응답을 중계해주는 역할을
   합니다.<br><br>
   예를 들어 gateway 의 포트번호가 8080 이고, eureka 에 등록된 다른 마이크로 서비스의 포트번호가 각각 11000, 12000 이라고 할 때,<br>
   클라이언트는 gateway 에 해당하는 8080 에 11000 에 해당하는 기능에 대한 요청을 gateway 에서 설정한 주소 체계에 따라 보내면, Gateway 가 Eureka 에서 찾은 11000 서버로
   요청을 보내고 응답을 받아 클라이언트에게 전달해주게 됩니다.<br><br>
   MSA 에 대한 도구로 spring cloud 를 선택한 구체적인 이유는,<br>
   eureka 서버 내에 복제된 여러 서비스를 동시에 올릴 시에 자동으로 로드 밸런싱 처리를 해주어 트래픽 분산 처리를 간단하게 구현해주며,<br>
   python 과 같이 spring 프레임워크 계열이 아닌 다른 개발 도구로 개발하더라도 동일한 기능을 보장하기 때문입니다.<br><br>
   ![화면 캡처 2025-01-22 122052](https://github.com/user-attachments/assets/a0825be8-1401-45d2-bc14-23c5ce281c61)<br><br>

3. 수평적 확장(Scale Out) 고려 :<br>
   위에서 설명 드렸듯 게시판 하나를 만들더라도 수평적 확장을 고려하며 개발을 해야만 합니다.<br>
   평시에는 최소한의 하드웨어 스펙으로 낭비되는 비용을 최소화 하다가도,<br>
   급작스런 트래픽 증가에도 기존 서비스에는 이상이 없도록 빠르게 대응할 수 있게 하기 위해서는, 서비스 복제를 하더라도 동일한 동작을 보장하는 구조를 고려해야만 합니다.<br>
   이를 위하여 Spring Cloud 를 통한 MSA 구조를 만들었으며, Redis, MongoDB, Kafka 와 같은 미들 웨어 역시 클러스터를 구성하는 방식을 사용하였습니다.<br><br>
   ![화면 캡처 2025-01-22 123307](https://github.com/user-attachments/assets/e04457e4-e7b6-4f49-9f50-db5c666195c5)<br><br>

4. 모듈 단위 TDD(Test Driven Development) :<br>
   멀티 모듈을 통하여 각 모듈 별 test 코드를 분리할 수 있습니다.<br>
   본 프로젝트에서는 적용하지 않았지만, 각 기능별 Test Case 를 고려하여 미리 테스트 코드를 만들어두는 TDD 방식을 사용한다면,<br>
   모듈에 대한 신뢰도를 얻을 수 있고, 라이브러리 버전 업, 사용 라이브러리 변경 등의 코드의 근본적인 부분에서의 변경점이 있더라도 빠르게 테스트를 진행할 수 있습니다.<br><br>
   ![화면 캡처 2025-01-22 123436](https://github.com/user-attachments/assets/feb56300-465d-43cc-86c3-ea9000496c89)<br><br>

### 다음으론 코드 내적에서의 고려사항입니다.

1. 코딩 사용 기술 소개 :<br>
    1) Kotlin : <br>
       Java 의 기본 철학을 그대로 계승하며, Java 에서 쉽게 변환이 가능한 언어이고,<br>
       Java 에서 제공하지 않는 여러 유용한 기능들을 제공합니다.<br>
       대표적으로, Kotlin 에서는 Java 진영에서 사용하는 LOMBOK 을 사용하지 않고도 해당 기능을 언어 자체적으로 지원하며,<br>
       특히 Kotlin 의 Nullable, Not Nullable 변수에 대한 제약은 언어 자체적으로 Null Safety 를 보장합니다.<br><br>

    2) JPA(QueryDSL) :<br>
       JPA 를 사용한 이유는, JDBC 나 Mybatis 와 같은 제가 사용해본 여타 데이터베이스 라이브러리보다 확실히 편리하고 보편적인 ORM 이기 때문입니다.
       Join 과 같은 복잡한 쿼리문에 대해선 QueryDSL 을 사용하여 서로 다른 데이터베이스 간에도 호환성을 보장할 수 있는 ORM 의 장점을 살렸습니다.<br><br>

    3) Swagger :<br>
       API 문서화를 따로 할 필요 없이 코드상으로 처리가 가능하게 해주는 유용한 라이브러리입니다.<br>
       Postman 과 같은 별도의 툴을 사용할 필요 없이 API 테스트 용도로도 손쉽게 사용할 수 있으며,<br>
       개발시에는 작성한 API 컨트롤러 코드에 대하여 설명을 강제하기에 따로 주석을 작성하지 않아도 코드에 대한 설명으로 작용한다는 장점을 가집니다.<br><br>

    4) Spring Security :<br>
       인증/인가 처리에 대하여 패턴화하여, 복잡할 수 있는 인증/인가 처리를 간편하게 설정 및 적용이 가능합니다.<br><br>

    5) Redis :<br>
       공유 메모리로 사용되며, 공유 락으로도 사용하고 있습니다.<br>
       클러스터링을 통한 메모리 안정화를 적용 가능합니다.<br><br>

    6) Kafka :<br>
       MSA 간의 이벤트 통신으로 사용하고 있습니다.<br>
       그룹 아이디를 통하여 서버 복제에 따른 스케일 아웃에도 대응됩니다.<br><br>

2. 프로젝트에서 사용하는 JPA 의 데이터베이스 설정은 멀티 소스를 고려하였습니다.<br>
   일반적으로는 JPA 설정을 1개 프로젝트에 1개의 데이터베이스를 사용하도록 설정하지만,<br>
   저는 프로젝트 한개에 대하여 여러 데이터 소스의 사용을 경험한 적이 있으므로 처음부터 이를 고려하여 언제든 데이터베이스 소스를 추가할 수 있습니다.<br><br>

3. JPA 관련 Entity, Repository 에 대한 코드는 모듈 내의 jpa_beans 경로 안에 모아두었으며,<br>
   @OneToMany, @ManyToOne, Unique 처리 등의 제약 조건을 적극적으로 사용하였습니다.<br>
   Join 문은 QueryDSL 을 사용하였으며, 정석적인 JPA 사용법을 적용하여 코드의 통일성을 높였습니다.<br><br>

4. JPA 트랜젝션 처리를 통하여 RuntimeException 시 롤백이 되도록 처리하였습니다.<br><br>

5. 데이터베이스 테이블 삭제시 외례키 관계에 따른 삭제 처리에 주의를 기울였습니다.<br>
   데이터 설계 단계에서부터 외례키 부모 테이블이 삭제되면 자식 테이블이 어떻게 처리 되어야 하는 지에 대한 설정을 고려하였습니다.<br><br>

6. 서로 분리된 두 마이크로 서비스간 연결을 위하여 Kafka 를 사용하였습니다.<br><br>
   본 프로젝트에서의 활용 내용을 설명드리자면,<br>
   인증/인가 모듈 내에서 회원 탈퇴 처리가 이루어졌다면 Kafka 를 통하여 해당 작업이 이루어졌다고 이벤트를 발생시키고,<br>
   그에 따른 처리가 필요한 board 모듈에서 해당 이벤트를 수신하여, 삭제된 회원의 테이블과 연결된 Board 관련 정보들을 삭제 처리 합니다.<br><br>
   이러한 방식을 통하여 서로 다른 두 모듈은 안정적이고 유기적으로 연결되면서도 느슨한 결합으로 인한 확장성을 유지할 수 있습니다.<br><br>
   ![화면 캡처 2025-01-22 124259](https://github.com/user-attachments/assets/1abf9db5-ff7e-4006-80d0-ee3b99f71b74)<br><br>

7. 병렬 처리에 대하여 고려하여 처리하였습니다.<br>
   게시판 API 중, 특정 게시글을 클릭했을 때, 게시글의 조회수가 1 올라가는 API 의 경우,<br>
   불특정 다수의 요청에 의하여 데이터베이스의 게시글 조회수 컬럼에 대해 경쟁 상태(Race Condition) 가 발생할 가능성이 있습니다.<br><br>
   Springboot 는 기본적으로 멀티 스레드로 병렬적으로 동시에 요청을 받을 수 있기에 일어나는 현상이므로,
   이에 따른 적절한 병렬 처리를 고려할 수 밖에 없습니다.<br><br>
   이에 대한 해결법으로 Redis 공유락을 구현하여 적용하였습니다.<br>
   병렬 처리 동작 검증을 위하여 은행 계좌 금액 동시 수정 테스트 샘플을 만들어 아래와 같이 테스트 하였습니다.<br><br>
   ![화면 캡처 2025-01-22 125043](https://github.com/user-attachments/assets/31399418-c2ff-408d-8dab-b529d3b01b2e)<br><br>

8. Filter 를 사용하여 API 요청과 응답에 대해 자동적으로 로깅을 하도록 처리하였습니다.<br>
   MultipartFile 과 같은 의미없는 큰 데이터는 로깅하지 않으며,<br>
   logback 설정을 통하여 로그 파일의 저장 경로와 로깅 방식 등을 설정하였습니다.<br>
   ELK 나 Grafana 에서 로깅 정보를 처리하기 쉽게 하기 위하여 가독성 있고 구분이 쉽도록 로그 형식을 정하였습니다.<br><br>

9. 인증/인가 방식은 JWT 를 사용하였습니다.<br>
   JWT 를 사용한 이유는, REST API 를 통한 서버-클라이언트 구조에 가장 적합한 방식이며,<br>
   서버 메모리 내에서 회원 정보를 저장할 필요가 없기에 서비스 호스트 입장에서 경제적이라는 장점 때문입니다.<br><br>
   JWT 구현은, Stateless 인증/인가 방식을 준수하였으며,<br>
   토큰 내 별도로 암호화된 정보를 활용하여 인증 로직을 수행할 때마다 발생할 수 있는 데이터베이스 접근을 최소화하고,<br>
   인증별 메모리 점유량을 줄일 수 있었습니다.<br><br>
   실시간 접근 금지 처리에 대한 기능 구현의 경우는 블랙리스트 방식을 사용하여 구현하였습니다.<br><br>

10. 모듈별 개발 폴더의 분리는 기능별로 구분해두었습니다.<br>
    예를 들어 @Configuration 어노테이션이 붙은 설정 파일은 configurations 에,<br>
    필터의 경우는 filters 폴더에,<br>
    jpa 와 관련된 entity, repository 등은 jpa_beans 에,<br>
    kafka 와 관련된 producer 나 consumer 파일들은 kafka_components 에 모아두는 방식을 사용하여,<br>
    직관적이고 실용성이 있는 구분 방식을 고수하여 사용함으로써 실용성을 확인했습니다.<br><br>
    ![화면 캡처 2025-01-25 141224](https://github.com/user-attachments/assets/f0b6f165-71cb-4ebb-84b0-0777a5b6f860)<br><br>

11. Swagger 를 사용하여 문서화 하는 것을 중시합니다.<br>
    서버의 역할은 클라이언트에 서비스를 서빙하는 것이고, API 문서를 공유하는 것이 중요합니다.<br><br>
    Swagger 라이브러리는 코드상으로 자동으로 API 를 문서화해주는 편리하고 좋은 도구이며,<br>
    controller 단의 코드상으로는 해당 API 에 대한 주석의 역할도 겸하기에 애용하고 있습니다.<br><br>
    ![화면 캡처 2025-01-22 125448](https://github.com/user-attachments/assets/805899a4-8ebd-4a6d-8ad9-8d1544e75299)<br>
    ![화면 캡처 2025-01-22 125517](https://github.com/user-attachments/assets/0df405b5-c0bc-4164-b447-1dc70201a0f5)<br><br>

12. application.yml 을 배포 환경인 prod 와 개발 환경인 dev, 그리고 로컬 환경인 local 로 나누어 프로세스 실행시의 실행 프로필에 따라 다른 설정이 적용되도록 하였습니다.<br><br>
    배포시에는 젠킨스와 같은 CI/CD 툴을 사용하여 배포를 자동화 할 것이며, 개발 서버와 배포 서버를 나누어 두 환경을 분리하도록 처리하였습니다.

## 이상으로

위와 같이 게시판 프로젝트를 하나 만드는 데에 어디까지 고려할 수 있는지에 대해 정리하였습니다.<br>

본 프로젝트는 이러한 사항들을 반영하여 작성된 결과물로서,<br>

이곳에서 보여드린 처리방식들을 사용하여,<br>

비동기 처리에 의한 데이터 무결성의 파괴,<br>
갑작스런 수요에 대응하지 못하여 발생하는 기회 비용의 발생,<br>
보안 취약점으로 인해 발생한 정보 유출 혹은 악의적이 정보 조작 등<br>

실무 상황에서 치명적일 수 있는 여러 리스크를 예방하고,<br>
모듈화된 구조를 기반으로 도메인 단위로 분리된 서비스가 어떻게 독립성을 유지하면서도 유기적으로 동작할 수 있는지를 보여드렸습니다.<br>

이상으로 본 프로젝트의 설명글을 마치겠습니다.