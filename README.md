# [포트폴리오 게시판 프로젝트]

## 게시판 프로젝트를 선택한 이유

게시판 서비스를 만드는 것은 웹 프로그래밍의 Hello World 라고 할 수 있는 아주 기초적인 서비스입니다.<br>
데이터베이스를 배우고, 웹 개발을 배운 상태에서 기본적인 CRUD 만으로 구축이 가능한 가장 기본적인 형태의 서비스로,<br>

데이터의 입력(Create), 출력(Read), 수정(Update), 삭제(Delete) 의 기본적인 조작 능력을 보여주며,<br>
데이터를 어떻게 다루어야 하는지에 대해 알 수 있는 필요 최소한의 기능의 묶음입니다.<br>

이렇듯 기본적인 서비스임에도 오늘날 많은 기업들이 게시판 프로젝트를 개발자의 실력을 측량하는 기준으로 보는 이유는,<br>

위에서 설명드렸듯 게시판 서비스가 웹 개발의 기본으로서, 웹 서비스 개발자에게 필요한 데이터를 다루는 방식과 실력을 가능하기 위한
필요 요소만을 심플하게 보여주는 좋은 예시이기 때문이며,<br>

평가자의 입장에서는 독특한 설계나 복잡한 알고리즘이 제외된 순수한 개발 능력과 방식을 알 수 있기에 빠르게 실력을 평가할 수 있기 때문이라 생각합니다.<br>

이러한 이유로 인해 저는 저의 개발 능력을 있는 그대로 보여드리기 위하여 게시판 프로젝트를 포트폴리오로 삼았습니다.

## 게시판 하나를 위해 어디까지 할 수 있을까?

게시판 서비스는 무척이나 단순한 서비스입니다.<br>
게시글을 저장하는 용도의 데이터베이스 테이블을 하나 만들고, 이곳에 CRUD 를 수행하는 API 만을 추가해도 게시판이라는 필요 최소한의 형태가 갖춰진 것이라고 말 할 수 있습니다.<br>

신입 개발자의 경우는 올바른 프로그래밍 지식과 기본적인 개발 능력을 갖추고 있는지와 코드에서 묻어나오는 코딩 습관 등을 파악하기 위해 이러한 것만을 고려하여도 될 것이지만,<br>
경력 개발자의 경우는 그에 더하여 해당 경력에 걸맞는 좋은 샘플 프로젝트가 어떤 것인지를 스스로 생각하는 사고력을 보여줘야만 할 것입니다.<br>

실제 개발 경험상으로 체득한 경험의 지혜와, 지속적인 공부를 통하여 얻은 학문의 지식을 결합하여,<br>
게시판 프로젝트를 하나 만들 때에 어디까지 고려할 수 있고,<br>
개발 실력을 어떻게 해야 최대한 구체적이고 인상적으로 표현할 수 있을 지에 대해 고민하였습니다.<br>

이러한 고민의 결과물로서,<br>
본 프로젝트를 평가하실 때 도움이 될 수 있도록,<br>
제가 고려했던 부분들에 대해 정리하여 설명드리겠습니다.

### 먼저 코드 외적인 부분에서의 고려 사항입니다.

1. 멀티 모듈 MSA 구조 :<br>
   게시판과 인증/인가 기능과 같이, 서로 다르지만 분명히 연관되는 기능을 구현하였을 때,<br>
   프로젝트 책임자의 관점에서 유지 보수 및 기능 추가에 대한 코스트를 낮추어 소프트웨어 공학적 목표를 달성할 수 있도록,<br>
   서로 다른 두 도메인을 MSA 개념으로 나누는 방식을 사용하였습니다.<br><br>
   본 프로젝트에서 보시는 바와 같이 각 마이크로 서비스는 모듈 단위로 나뉘어져 있고,<br>
   각 모듈은 서로 다른 포트번호를 점유하도록 설계하여 결합성을 약화 시켜 독립성을 재고하였습니다.<br>
   이러한 아키텍쳐 측면에서의 처리는 추후 문제가 발생하는 위치에 대한 디버깅을 용이하게 하고,<br>
   서로 다른 코딩 스타일을 가진 숙련된 개발자들간의 독립성을 보장하며,<br>
   코드 재활용 및 대체가 무척이나 용이하게 해주는 장점이 있습니다.<br><br>
   ![화면 캡처 2025-01-22 120750](https://github.com/user-attachments/assets/f15680a0-bfd8-4929-a553-2960dd63470f)<br>
   ![화면 캡처 2025-01-22 120833](https://github.com/user-attachments/assets/4717369d-11d5-4937-a50e-4d8605adbbe6)<br><br>
   아래 도표는 인증/인가 도메인과 게시판 도메인을 MSA 에 맞게 분리했을 때의 동작 구조를 보여줍니다.<br><br>
   ![화면 캡처 2025-01-26 195530](https://github.com/user-attachments/assets/080167a1-8191-4ed7-8020-192a49c1dded)<br><br>

2. 효율적인 MSA 구축 및 관리를 위한 Spring Cloud 사용 :<br>
   MSA 를 구축할 때에 저는 Spring Cloud 라이브러리를 사용하였습니다.<br><br>
   cloud-eureka 모듈은, auth 나 board 와 같은 마이크로 서비스를 저장하는 역할을 합니다.<br>
   MSA 에서 저금통과 같은 역할을 하며, 모든 마이크로 서비스는 이곳에 모이므로 간단히 상태를 파악하거나, 다른 서비스에서 이러한 정보를 응용할 수 있습니다.<br><br>
   cloud-gateway 모듈은 클라이언트에게 요청을 받으면, eureka 서버에 등록된 마이크로 서비스를 탐색하고 클라이언트가 요청한 적절한 기능을 가진 마이크로 서비스의 응답을 중계해주는 역할을
   합니다.<br><br>
   예를 들어 gateway 의 포트번호가 8080 이고, eureka 에 등록된 다른 마이크로 서비스의 포트번호가 각각 11000, 12000 이라고 할 때,<br>
   클라이언트는 gateway 에 해당하는 8080 에 11000 에 해당하는 기능에 대한 요청을 gateway 에서 설정한 주소 체계에 따라 보내면, Gateway 가 Eureka 에서 찾은 11000 서버로
   요청을 보내고 응답을 받아 클라이언트에게 전달해주게 됩니다.<br><br>
   MSA 에 대한 도구로 spring cloud 를 선택한 구체적인 이유는,<br>
   eureka 서버 내에 복제된 여러 서비스를 동시에 올릴 시에 자동으로 로드 밸런싱 처리를 해주어 트래픽 분산 처리를 간단하게 구현해주며,<br>
   python 과 같이 spring 프레임워크 계열이 아닌 다른 개발 도구로 개발하더라도 동일한 기능을 보장하기 때문입니다.<br><br>
   ![화면 캡처 2025-01-22 122052](https://github.com/user-attachments/assets/a0825be8-1401-45d2-bc14-23c5ce281c61)<br><br>

3. 수평적 확장(Scale Out) 고려 :<br>
   위에서 설명 드렸듯 게시판 하나를 만들더라도 수평적 확장을 고려하며 개발을 해야만 합니다.<br>
   평시에는 최소한의 하드웨어 스펙으로 낭비되는 비용을 최소화 하다가도,<br>
   급작스런 트래픽 증가에도 기존 서비스에는 이상이 없도록 빠르게 대응할 수 있게 하기 위해서는, 서비스 복제를 하더라도 동일한 동작을 보장하는 구조를 고려해야만 합니다.<br>
   대표적인 예로는, 서버가 하드웨어 메모리상으로 상태값을 갖게 되면, 이를 복제하였을 때, 복제된 서버와 상태값이 불일치 할 것을 고려해야만 하는 것입니다.<br>
   이를 위하여 2번에서와 같이 Spring Cloud 를 통한 MSA 구조를 만들었으며, Redis, MongoDB, Kafka 와 같은 미들 웨어 역시 클러스터를 구성하는 방식을 사용하였습니다.<br><br>
   ![화면 캡처 2025-01-22 123307](https://github.com/user-attachments/assets/e04457e4-e7b6-4f49-9f50-db5c666195c5)<br><br>

4. 모듈 단위 TDD(Test Driven Development) :<br>
   멀티 모듈을 통하여 각 도메인 별 test 코드를 달리 둘 수 있습니다.<br>
   본 프로젝트에서는 적용하지 않았지만, 각 기능별 Test Case 를 고려하여 미리 테스트 코드를 만들어두는 TDD 방식을 사용한다면,<br>
   모듈에 대한 신뢰도를 얻을 수 있고, 라이브러리 버전 업, 사용 라이브러리 변경 등의 코드의 근본적인 부분에서의 변경점이 있더라도 빠르게 테스트를 진행할 수 있습니다.<br><br>
   ![화면 캡처 2025-01-22 123436](https://github.com/user-attachments/assets/feb56300-465d-43cc-86c3-ea9000496c89)<br><br>

### 다음으론 코드 내적에서의 고려사항입니다.

1. 코딩 사용 기술 소개 :<br>
    1) Kotlin : <br>
       Java 의 기본 철학을 그대로 계승하며, Java 에서 쉽게 변환이 가능한 언어이고,<br>
       또한, Java 에서 제공하지 않는 여러 유용한 기능들을 제공합니다.<br>
       대표적으로, Kotlin 에서는 Java 진영에서 사용하는 LOMBOK 을 사용하지 않고도 해당 기능을 언어 자체적으로 지원하며,<br>
       특히 Kotlin 의 Nullable, Not Nullable 변수에 대한 제약은 언어 자체적으로 Null Safety 를 보장합니다.<br><br>

    2) JPA(QueryDSL) :<br>
       JPA 를 사용한 이유는, JDBC 나 Mybatis 와 같은 제가 사용해본 여타 데이터베이스 라이브러리보다 확실히 편리하고 보편적인 ORM 이기 때문입니다.
       Join 과 같은 복잡한 쿼리문에 대해선 QueryDSL 을 사용하여 서로 다른 데이터베이스 간에도 호환성을 보장할 수 있는 ORM 의 장점을 살렸습니다.<br><br>

    3) Retrofit2 :<br>
       Springboot 진영에서 네트워크 요청 라이브러리로 자주 사용되는 RestTemplate 이나 WebClient 를 놔두고 Retrofit2 를 사용한 이유는,<br>
       Retrofit2 가 안드로이드 진영에서 자주 사용되던 것이기에 안드로이드 개발과 병행하던 시절에 혼용해 사용하기 위해서 선택했던 것입니다.<br>
       물론 이러한 이유뿐 아니라, Retrofit2 는 OKHTTP 를 래핑하여 모바일 환경을 위해 만들어진 라이브러리이므로 빠르고 가볍다는 장점도 있으며, 사용법도 간단하다는 장점이 있습니다.<br><br>

    4) Swagger :<br>
       클라이언트에 대한 문서화 기능으로 매우 유용한 기능을 제공해줍니다.<br>
       개발시에는 작성한 API 컨트롤러 코드에 대하여 설명을 강제하기에 따로 주석을 작성하지 않아도 코드에 대한 설명으로 작용한다는 장점을 가집니다.<br><br>

    5) Spring Security :<br>
       인증/인가 처리에 대하여 패턴화하여, 복잡할 수 있는 인증/인가 처리를 간편하게 설정 및 적용이 가능합니다.<br><br>

    6) Redis :<br>
       공유 메모리로 사용되며, 공유 락으로도 사용하고 있습니다.<br>
       클러스터링을 통한 메모리 안정화를 적용 가능합니다.<br><br>

    7) Kafka :<br>
       MSA 간의 이벤트 통신으로 사용하고 있습니다.<br>
       그룹 아이디를 통하여 서버 복제에 따른 스케일 아웃에도 대응됩니다.<br><br>

2. 프로젝트에서 사용하는 JPA 의 데이터베이스 설정은 멀티 소스를 고려하였습니다.<br>
   일반적으로는 JPA 설정을 1개 프로젝트에 1개의 데이터베이스를 사용하도록 설정하지만,<br>
   저는 프로젝트 한개에 대하여 여러 데이터 소스의 사용을 경험한 적이 있으므로 처음부터 이를 고려하였습니다.<br><br>

3. JPA 관련 Entity, Repository 에 대한 코드는 모듈 내의 jpa_beans 경로 안에 모아두었으며,<br>
   @OneToMany, @ManyToOne, Unique 처리 등의 제약 조건을 적극적으로 사용하였습니다.<br>
   Join 문은 QueryDSL 을 사용하였으며, 정석적인 JPA 사용법을 적용하였습니다.<br><br>

4. JPA 트랜젝션 처리를 통하여 RuntimeException 시 롤백이 되도록 처리하였습니다.<br><br>

5. 데이터베이스 테이블 삭제시 외례키 관계에 따른 삭제 처리에 주의를 기울였습니다.<br>
   데이터 설계 단계에서부터 외례키 부모 테이블이 삭제되면 자식 테이블이 어떻게 처리 되어야 하는 지에 대한 설정을 고려하였습니다.<br><br>

6. 서로 분리된 두 마이크로 서비스간 연결을 위하여 Kafka 를 사용하였습니다.<br><br>
   본 프로젝트에서는 데이터베이스 테이블 삭제시의 처리를 위해 적용하였으며,<br>
   인증/인가 모듈 내에서 회원 탈퇴 처리가 이루어졌다면 Kafka 를 통하여 해당 작업이 이루어졌다고 이벤트를 발생시킵니다.<br>
   그에 따른 처리가 필요한 board 모듈에서는 이벤트로 넘어온 회원의 고유번호를 확인하여 해당 회원 테이블과 연결된 정보들을 삭제 처리 합니다.<br><br>
   이러한 방식을 통하여 이벤트 producer 에 해당하는 모듈에서는 외부 모듈에 의존성을 가지지 않고 행위를 유도할 수 있으며,<br>
   추후 해당 회원 정보를 이용하는 어떠한 모듈이 추가되더라도 마치 하나의 서비스 인 것 처럼 처리할 수 있습니다.<br><br>
   저는 Kafka 정보 교환의 방식으로, 상호간 String 타입으로 정보를 주고 받는 것으로 설정하였고,<br>
   이를 Json 형식으로 미리 정해진 데이터 형태를 약속하는 방식으로 보다 복잡한 정보를 교환 할 수 있도록 하였습니다.<br><br>
   ![화면 캡처 2025-01-22 124259](https://github.com/user-attachments/assets/1abf9db5-ff7e-4006-80d0-ee3b99f71b74)<br><br>

7. 게시판 API 중, 특정 게시글을 클릭했을 경우 게시글의 조회수가 1 올라가는 API 의 경우,<br>
   데이터베이스의 게시글 조회수 컬럼에 대해 경쟁 상태(Race Condition) 이 발생할 가능성이 있습니다.<br><br>
   Springboot 는 기본적으로 멀티 스레드로 병렬적으로 동시에 요청을 받을 수 있기에 일어나는 현상이므로,
   이에 따른 적절한 병렬 처리를 고려할 수 밖에 없습니다.<br><br>
   저는 Redis 의 싱글 스레드 처리 방식을 이용하여, 데이터베이스 락 보다 빠르고 성능이 좋은 Redis 공유락을 구현하여 적용하였습니다.<br><br>
   병렬 처리 동작 검증을 위하여 은행 계좌 금액 동시 수정 테스트 샘플을 만들어 아래와 같이 테스트 하였습니다.<br><br>
   ![화면 캡처 2025-01-22 125043](https://github.com/user-attachments/assets/31399418-c2ff-408d-8dab-b529d3b01b2e)<br><br>

8. Filter 를 사용하여 API 요청과 응답에 대해 자동적으로 로깅을 하도록 처리하였습니다.<br>
   Multipart 와 같은 의미없는 큰 데이터는 로깅하지 않으며,<br>
   logback 설정을 통하여 로그 파일의 저장 경로와 로깅 방식 등을 설정하였습니다.<br>
   ELK 나 Grafana 에서 로깅 정보를 처리하기 쉽게 하기 위하여 가독성 있고 구분이 쉽도록 로그 형식을 정하였습니다.<br><br>

9. 인증/인가 방식은 JWT 를 사용하였습니다.<br>
   JWT 를 사용한 이유는, REST API 를 통한 서버-클라이언트 구조에 가장 적합한 방식이며,<br>
   서버 메모리 내에서 회원 정보를 저장할 필요가 없기에 서비스 호스트 입장에서 경제적이라는 장점 때문입니다.<br><br>
   JWT 구현은, Stateless 인증/인가 방식을 준수하였으며,<br>
   토큰 내 별도로 암호화된 정보를 활용하여 인증 로직을 수행할 때마다 발생할 수 있는 데이터베이스 접근을 최소화하고,<br>
   인증별 메모리 점유량을 줄일 수 있었습니다.<br><br>
   실시간 접근 금지 처리에 대한 기능 구현의 경우는 블랙리스트 방식을 사용하여 구현하였습니다.<br><br>

10. 모듈별 개발 폴더의 분리는 기능별로 구분해두었습니다.<br>
    예를 들어 @Configuration 어노테이션이 붙은 설정 파일은 configurations 에,<br>
    필터의 경우는 filters 폴더에,<br>
    jpa 와 관련된 entity, repository 등은 jpa_beans 에,<br>
    kafka 와 관련된 producer 나 consumer 파일들은 kafka_components 에 모아두는 방식을 사용하여,<br>
    직관적이고 실용성이 있는 구분 방식을 고수하여 사용함으로써 실전성을 확인했습니다.<br><br>
    ![화면 캡처 2025-01-25 141224](https://github.com/user-attachments/assets/f0b6f165-71cb-4ebb-84b0-0777a5b6f860)<br><br>

11. Swagger 를 사용하여 문서화 하는 것을 중시합니다.<br>
    서버의 역할은 클라이언트에 서비스를 서빙하는 것이고, API 문서를 공유하는 것이 중요합니다.<br><br>
    Swagger 라이브러리는 코드상으로 자동으로 API 를 문서화해주는 편리하고 좋은 도구이며,<br>
    controller 단의 코드상으로는 해당 API 에 대한 주석의 역할도 겸하기에 애용하고 있습니다.<br><br>
    ![화면 캡처 2025-01-22 125448](https://github.com/user-attachments/assets/805899a4-8ebd-4a6d-8ad9-8d1544e75299)<br>
    ![화면 캡처 2025-01-22 125517](https://github.com/user-attachments/assets/0df405b5-c0bc-4164-b447-1dc70201a0f5)<br><br>

12. application.yml 을 배포 환경인 prod 와 개발 환경인 dev, 그리고 로컬 환경인 local 로 나누어 프로세스 실행시의 실행 프로필에 따라 다른 설정이 적용되도록 하였습니다.<br><br>
    배포시에는 젠킨스와 같은 CI/CD 툴을 사용하여 배포를 자동화 할 것이며, 개발 서버와 배포 서버를 나누어 두 환경을 분리하도록 처리하였습니다.

## 이상으로

위와 같이 게시판 프로젝트를 하나 만드는 데에 어디까지 고려할 수 있는지에 대해 정리하였고,<br>
본 프로젝트는 이러한 사항들을 반영하여 작성된 결과물입니다.<br>

서비스를 이용하는 고객의 입장에선 본 프로젝트가 구현한 서비스는 따로 설명할 필요도 없는 단순한 서비스일 뿐이겠지만,<br>
서버 개발자의 입장에서는 겉으로 보이는 기능 구현을 넘어서 완성도 높은 프로그램을 구현하기 위하여 고려해야 할 사항이 눈에 보이는 것 이상으로 많다는 것을 보여주는 예시로,<br>

제가 경험해본 다른 개발자 분들과 업무 경험을 떠올리며, 단순히 지시 받은 대로 코딩을 하고 시간을 보내며 경력을 쌓은 것이 아니라는 것을 증명하고자 하는 목표로 작성해 보았습니다.<br>

제가 개발을 처음 시작한 시점의 개발 트랜드와 현재의 트랜드를 비교하였을 때 굉장히 많은 변화가 있어왔고, 앞으로도 있을 것이라고 생각합니다.<br>

그때마다 더 좋은 방식이 있다면, 해당 방식을 흡수하며 본 프로젝트 역시 변경을 해야할 것이지만,<br>

근본적으로는 올바른 설계와, MSA 와 같은 느슨한 결합이라는 구조를 고려하였다면,<br>
추후 라이브러리나 코딩 스타일이 어떻게 변하든 기존 서비스에 대해서는 영향을 끼치지 않는 안정적인 구조를 보장할 것이고,<br>
그렇지않고 단순히 기능 구현만을 추구하였다면 사소한 기술적 변경 사항에도 취약점이 많이 생겨나는 좋지 못한 구조를 가질 것이라는 정리를 마지막으로 본 프로젝트의 설명글을 마칩니다.
