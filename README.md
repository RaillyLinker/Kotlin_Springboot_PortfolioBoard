# [포트폴리오 게시판 프로젝트]

## 꼭 읽어주세요
안녕하세요.<br>
개발자 RaillyLinker 입니다.<br>

본 프로젝트는 백엔드 개발 분야에 대하여 제가 가진 개발 능력을 객관적으로 보여드리기 위하여 준비한 포트폴리오 프로젝트입니다.<br>

주된 기술 스택은 Springboot, Kotlin, JPA, Kafka, Redis, Spring Security 를 사용하였으며,<br>
멀티 모듈 구조를 이용한 MSA 를 구현하였습니다.<br>

위와 같은 기술에 대해 익숙하신 분이라면, 보편적인 방식으로 최대한 쉬운 구조를 지향하여 코딩하였으므로, 코드를 직접 파악해보시는 것을 추천드리며,<br>
적어도 아래의 설명글 만큼은 훑어보시고 판단의 근거로 삼아주시길 바랍니다.<br>

프론트앤드 포트폴리오와 같이 확실히 눈에 보이는 결과물을 보일 수는 없는 백엔드 영역의 특성상,<br>
백엔드 개발자로서 필요한 지식을 갖추고 있다는 증거를 구체적으로 보여드리는 것을 목표로 글을 작성하였습니다.

## 게시판 프로젝트를 선택한 이유

게시판 서비스를 만드는 것은 웹 프로그래밍의 Hello World 라고 할 수 있는 아주 기초적인 서비스입니다.<br>
데이터베이스를 배우고, 웹 개발을 배운 상태에서 기본적인 CRUD 만으로 구축이 가능한 가장 기본적인 형태의 서비스로,<br>

데이터의 입력(Create), 출력(Read), 수정(Update), 삭제(Delete) 의 기본적인 조작 능력을 보여주며,<br>
데이터를 어떻게 다루어야 하는지에 대해 알 수 있는 필요 최소한의 기능의 묶음입니다.<br>

이렇듯 기본적인 서비스임에도 많은 기업들이 게시판 프로젝트를 개발자의 실력을 측량하는 기준으로 요구하는 이유는,<br>

게시판 서비스가 웹 개발의 기본으로서, 웹 서비스 개발자에게 필요한 데이터를 다루는 방식과 실력을 가능하기 위한
필요 요소만을 심플하게 보여주는 좋은 예시이기 때문이며,<br>

데이터의 CRUD 라는 기본적 골격에 더불어 결제 기능을 추가하여 쇼핑몰을 구축하거나,<br>
보다 복잡한 상태값의 관리를 통하여 예약 시스템, 배달 시스템, 경영 지원 시스템 등을 구축하거나,<br>
실시간 소켓 통신을 적용하여 채팅방 시스템을 구축하는 등<br>
네트워크 서비스 개발을 함에 있어서 필요한 기본적이면서도 필수적인 영역의 개발 능력을 보여주며,<br>

평가자의 입장에서는 독특한 설계나 복잡한 알고리즘이 제외된 순수한 개발 능력과 방식을 알 수 있기에 빠르게 실력을 평가할 수 있기 때문이라 생각합니다.<br>

이러한 이유로 게시판 서비스를 포트폴리오 프로젝트로 선택하였습니다.

## 게시판 하나를 위해 어디까지 할 수 있을까?

게시판 서비스는 무척이나 단순한 서비스입니다.<br>
게시글을 저장하는 용도의 데이터베이스 테이블을 하나 만들고, 이곳에 CRUD 를 수행하는 API 만을 추가해도 게시판이라는 필요 최소한의 형태가 갖춰진 것이라고 말 할 수 있습니다.<br>

신입 개발자의 경우는 올바른 프로그래밍 지식과 기본적인 개발 능력을 갖추고 있는지와 코드에서 묻어나오는 코딩 습관 등을 파악하기 위해 이러한 것만을 고려하여도 될 것이지만,<br>

경력 개발자의 경우는 그에 더하여 해당 경력에 걸맞는 좋은 샘플 프로젝트가 어떤 것인지를 스스로 생각하는 사고력을 보여줘야만 할 것입니다.<br>

실제 개발 경험상으로 체득한 경험의 지혜와, 지속적인 공부를 통하여 얻은 학문의 지식을 결합하여,<br>
게시판 프로젝트를 하나 만들 때에 어디까지 고려할 수 있고,<br>
개발 실력을 어떻게 해야 최대한 구체적이고 인상적으로 표현할 수 있을 지에 대해 고민하였습니다.<br>

이러한 고민의 결과물로서,<br>
본 프로젝트를 평가하실 때 도움이 될 수 있도록,<br>
제가 고려했던 부분들에 대해 정리하여 설명드리겠습니다.

### 먼저 코드 외적인 부분에서의 고려 사항입니다.

1. 멀티 모듈 MSA 구조 :<br>
   게시판과 인증/인가 기능과 같이, 서로 다르지만 분명히 연관되는 기능을 구현하였을 때,<br>
   프로젝트 책임자의 관점에서 유지 보수 및 기능 추가에 대한 코스트를 낮추어 소프트웨어 공학적 목표를 달성할 수 있도록,<br>
   서로 다른 두 도메인을 MSA 개념으로 나누는 방식을 사용하였습니다.<br><br>
   본 프로젝트에서 보시는 바와 같이 각 마이크로 서비스는 모듈 단위로 나뉘어져 있고,<br>
   각 모듈은 서로 다른 포트번호를 점유하도록 설계하여 결합성을 약화 시켜 독립성을 재고하였습니다.<br>
   이러한 아키텍쳐 측면에서의 처리는 추후 문제가 발생하는 위치에 대한 디버깅을 용이하게 하고,<br>
   서로 다른 코딩 스타일을 가진 숙련된 개발자들간의 독립성을 보장하며,<br>
   코드 재활용 및 대체가 무척이나 용이하게 해주는 장점이 있습니다.<br><br>
   ![화면 캡처 2025-01-22 120750](https://github.com/user-attachments/assets/f15680a0-bfd8-4929-a553-2960dd63470f)<br>
   ![화면 캡처 2025-01-22 120833](https://github.com/user-attachments/assets/4717369d-11d5-4937-a50e-4d8605adbbe6)<br><br>
   아래 도표는 인증/인가 도메인과 게시판 도메인을 MSA 에 맞게 분리했을 때의 구조를 보여줍니다.<br><br>
   ![화면 캡처 2025-01-26 195530](https://github.com/user-attachments/assets/ddb7aa70-3e5b-433c-9693-f34bbb84b07b)<br><br>

2. 효율적인 MSA 구축 및 관리를 위한 Spring Cloud 사용 :<br>
   MSA 를 구축할 때에 저는 Spring Cloud 라이브러리를 사용하였습니다.<br><br>
   cloud-eureka 모듈은, auth 나 board 와 같은 마이크로 서비스를 저장하는 역할을 합니다.<br>
   MSA 에서 저금통과 같은 역할을 하며, 모든 마이크로 서비스는 이곳에 모이므로 간단히 상태를 파악하거나, 다른 서비스에서 이러한 정보를 응용할 수 있습니다.<br><br>
   cloud-gateway 모듈은 클라이언트에게 요청을 받으면, eureka 서버에 등록된 마이크로 서비스를 탐색하고 클라이언트가 요청한 적절한 기능을 가진 마이크로 서비스의 응답을 중계해주는 역할을
   합니다.<br><br>
   예를 들어 gateway 의 포트번호가 8080 이고, eureka 에 등록된 다른 마이크로 서비스의 포트번호가 각각 11000, 12000 이라고 할 때,<br>
   클라이언트는 gateway 에 해당하는 8080 에 11000 에 해당하는 기능에 대한 요청을 gateway 에서 설정한 주소 체계에 따라 보내면, Gateway 가 Eureka 에서 찾은 11000 서버로
   요청을 보내고 응답을 받아 클라이언트에게 전달해주게 됩니다.<br><br>
   MSA 에 대한 도구로 spring cloud 를 선택한 구체적인 이유는,<br>
   eureka 서버 내에 복제된 여러 서비스를 동시에 올릴 시에 자동으로 로드 밸런싱 처리를 해주어 트래픽 분산 처리를 간단하게 구현해주며,<br>
   python 과 같이 spring 프레임워크 계열이 아닌 다른 개발 도구로 개발하더라도 동일한 기능을 보장하기 때문입니다.<br><br>
   ![화면 캡처 2025-01-22 122052](https://github.com/user-attachments/assets/a0825be8-1401-45d2-bc14-23c5ce281c61)<br><br>

3. 수평적 확장(Scale Out) 고려 :<br>
   위에서 설명 드렸듯 게시판 하나를 만들더라도 수평적 확장을 고려하며 개발을 해야만 합니다.<br>
   평시에는 최소한의 하드웨어 스펙으로 낭비되는 비용을 최소화 하다가도,<br>
   급작스런 트래픽 증가에도 기존 서비스에는 이상이 없도록 빠르게 대응할 수 있게 하기 위해서는, 서비스 복제를 하더라도 동일한 동작을 보장하는 구조를 고려해야만 합니다.<br>
   이를 위하여 Spring Cloud 를 통한 MSA 구조를 만들었으며, Redis, MongoDB, Kafka 와 같은 미들 웨어 역시 클러스터를 구성하는 방식을 사용하였습니다.<br><br>
   ![화면 캡처 2025-01-22 123307](https://github.com/user-attachments/assets/e04457e4-e7b6-4f49-9f50-db5c666195c5)<br><br>

4. 모듈 단위 TDD(Test Driven Development) :<br>
   멀티 모듈을 통하여 각 모듈 별 test 코드를 분리할 수 있습니다.<br>
   본 프로젝트에서는 적용하지 않았지만, 각 기능별 Test Case 를 고려하여 미리 테스트 코드를 만들어두는 TDD 방식을 사용한다면,<br>
   모듈에 대한 신뢰도를 얻을 수 있고, 라이브러리 버전 업, 사용 라이브러리 변경 등의 코드의 근본적인 부분에서의 변경점이 있더라도 빠르게 테스트를 진행할 수 있습니다.<br><br>
   ![화면 캡처 2025-01-22 123436](https://github.com/user-attachments/assets/feb56300-465d-43cc-86c3-ea9000496c89)<br><br>

### 다음으론 코드 내적에서의 고려사항입니다.

1. 코딩 사용 기술 소개 :<br>
    1) Kotlin : <br>
       Java 의 기본 철학을 그대로 계승하며, Java 에서 쉽게 변환이 가능한 언어이고,<br>
       Java 에서 제공하지 않는 여러 유용한 기능들을 제공합니다.<br>
       대표적으로, Kotlin 에서는 Java 진영에서 사용하는 LOMBOK 을 사용하지 않고도 해당 기능을 언어 자체적으로 지원하며,<br>
       특히 Kotlin 의 Nullable, Not Nullable 변수에 대한 제약은 언어 자체적으로 Null Safety 를 보장합니다.<br><br>

    2) JPA(QueryDSL) :<br>
       JPA 를 사용한 이유는, JDBC 나 Mybatis 와 같은 제가 사용해본 여타 데이터베이스 라이브러리보다 확실히 편리하고 보편적인 ORM 이기 때문입니다.
       Join 과 같은 복잡한 쿼리문에 대해선 QueryDSL 을 사용하여 서로 다른 데이터베이스 간에도 호환성을 보장할 수 있는 ORM 의 장점을 살렸습니다.<br><br>

    3) Swagger :<br>
       클라이언트에 대한 문서화 기능으로 매우 유용한 기능을 제공해줍니다.<br>
       개발시에는 작성한 API 컨트롤러 코드에 대하여 설명을 강제하기에 따로 주석을 작성하지 않아도 코드에 대한 설명으로 작용한다는 장점을 가집니다.<br><br>

    4) Spring Security :<br>
       인증/인가 처리에 대하여 패턴화하여, 복잡할 수 있는 인증/인가 처리를 간편하게 설정 및 적용이 가능합니다.<br><br>

    5) Redis :<br>
       공유 메모리로 사용되며, 공유 락으로도 사용하고 있습니다.<br>
       클러스터링을 통한 메모리 안정화를 적용 가능합니다.<br><br>

    6) Kafka :<br>
       MSA 간의 이벤트 통신으로 사용하고 있습니다.<br>
       그룹 아이디를 통하여 서버 복제에 따른 스케일 아웃에도 대응됩니다.<br><br>

2. 프로젝트에서 사용하는 JPA 의 데이터베이스 설정은 멀티 소스를 고려하였습니다.<br>
   일반적으로는 JPA 설정을 1개 프로젝트에 1개의 데이터베이스를 사용하도록 설정하지만,<br>
   저는 프로젝트 한개에 대하여 여러 데이터 소스의 사용을 경험한 적이 있으므로 처음부터 이를 고려하였습니다.<br><br>

3. JPA 관련 Entity, Repository 에 대한 코드는 모듈 내의 jpa_beans 경로 안에 모아두었으며,<br>
   @OneToMany, @ManyToOne, Unique 처리 등의 제약 조건을 적극적으로 사용하였습니다.<br>
   Join 문은 QueryDSL 을 사용하였으며, 정석적인 JPA 사용법을 적용하였습니다.<br><br>

4. JPA 트랜젝션 처리를 통하여 RuntimeException 시 롤백이 되도록 처리하였습니다.<br><br>

5. 데이터베이스 테이블 삭제시 외례키 관계에 따른 삭제 처리에 주의를 기울였습니다.<br>
   데이터 설계 단계에서부터 외례키 부모 테이블이 삭제되면 자식 테이블이 어떻게 처리 되어야 하는 지에 대한 설정을 고려하였습니다.<br><br>

6. 서로 분리된 두 마이크로 서비스간 연결을 위하여 Kafka 를 사용하였습니다.<br><br>
   본 프로젝트에서의 활용 내용을 설명드리자면,<br>
   인증/인가 모듈 내에서 회원 탈퇴 처리가 이루어졌다면 Kafka 를 통하여 해당 작업이 이루어졌다고 이벤트를 발생시키고,<br>
   그에 따른 처리가 필요한 board 모듈에서 해당 이벤트를 수신하여, 삭제된 회원의 테이블과 연결된 Board 관련 정보들을 삭제 처리 합니다.<br><br>
   이러한 방식을 통하여 서로 다른 두 모듈은 안정적이고 유기적으로 연결되면서도 느슨한 결합으로 인한 확장성을 유지할 수 있습니다.<br><br>
   ![화면 캡처 2025-01-22 124259](https://github.com/user-attachments/assets/1abf9db5-ff7e-4006-80d0-ee3b99f71b74)<br><br>

7. 병렬 처리에 대하여 고려하여 처리하였습니다.<br>
   게시판 API 중, 특정 게시글을 클릭했을 때, 게시글의 조회수가 1 올라가는 API 의 경우,<br>
   불특정 다수의 요청에 의하여 데이터베이스의 게시글 조회수 컬럼에 대해 경쟁 상태(Race Condition) 가 발생할 가능성이 있습니다.<br><br>
   Springboot 는 기본적으로 멀티 스레드로 병렬적으로 동시에 요청을 받을 수 있기에 일어나는 현상이므로,
   이에 따른 적절한 병렬 처리를 고려할 수 밖에 없습니다.<br><br>
   이에 대한 해결법으로 Redis 공유락을 구현하여 적용하였습니다.<br>
   병렬 처리 동작 검증을 위하여 은행 계좌 금액 동시 수정 테스트 샘플을 만들어 아래와 같이 테스트 하였습니다.<br><br>
   ![화면 캡처 2025-01-22 125043](https://github.com/user-attachments/assets/31399418-c2ff-408d-8dab-b529d3b01b2e)<br><br>

8. Filter 를 사용하여 API 요청과 응답에 대해 자동적으로 로깅을 하도록 처리하였습니다.<br>
   MultipartFile 과 같은 의미없는 큰 데이터는 로깅하지 않으며,<br>
   logback 설정을 통하여 로그 파일의 저장 경로와 로깅 방식 등을 설정하였습니다.<br>
   ELK 나 Grafana 에서 로깅 정보를 처리하기 쉽게 하기 위하여 가독성 있고 구분이 쉽도록 로그 형식을 정하였습니다.<br><br>

9. 인증/인가 방식은 JWT 를 사용하였습니다.<br>
   JWT 를 사용한 이유는, REST API 를 통한 서버-클라이언트 구조에 가장 적합한 방식이며,<br>
   서버 메모리 내에서 회원 정보를 저장할 필요가 없기에 서비스 호스트 입장에서 경제적이라는 장점 때문입니다.<br><br>
   JWT 구현은, Stateless 인증/인가 방식을 준수하였으며,<br>
   토큰 내 별도로 암호화된 정보를 활용하여 인증 로직을 수행할 때마다 발생할 수 있는 데이터베이스 접근을 최소화하고,<br>
   인증별 메모리 점유량을 줄일 수 있었습니다.<br><br>
   실시간 접근 금지 처리에 대한 기능 구현의 경우는 블랙리스트 방식을 사용하여 구현하였습니다.<br><br>

10. 모듈별 개발 폴더의 분리는 기능별로 구분해두었습니다.<br>
    예를 들어 @Configuration 어노테이션이 붙은 설정 파일은 configurations 에,<br>
    필터의 경우는 filters 폴더에,<br>
    jpa 와 관련된 entity, repository 등은 jpa_beans 에,<br>
    kafka 와 관련된 producer 나 consumer 파일들은 kafka_components 에 모아두는 방식을 사용하여,<br>
    직관적이고 실용성이 있는 구분 방식을 고수하여 사용함으로써 실용성을 확인했습니다.<br><br>
    ![화면 캡처 2025-01-25 141224](https://github.com/user-attachments/assets/f0b6f165-71cb-4ebb-84b0-0777a5b6f860)<br><br>

11. Swagger 를 사용하여 문서화 하는 것을 중시합니다.<br>
    서버의 역할은 클라이언트에 서비스를 서빙하는 것이고, API 문서를 공유하는 것이 중요합니다.<br><br>
    Swagger 라이브러리는 코드상으로 자동으로 API 를 문서화해주는 편리하고 좋은 도구이며,<br>
    controller 단의 코드상으로는 해당 API 에 대한 주석의 역할도 겸하기에 애용하고 있습니다.<br><br>
    ![화면 캡처 2025-01-22 125448](https://github.com/user-attachments/assets/805899a4-8ebd-4a6d-8ad9-8d1544e75299)<br>
    ![화면 캡처 2025-01-22 125517](https://github.com/user-attachments/assets/0df405b5-c0bc-4164-b447-1dc70201a0f5)<br><br>

12. application.yml 을 배포 환경인 prod 와 개발 환경인 dev, 그리고 로컬 환경인 local 로 나누어 프로세스 실행시의 실행 프로필에 따라 다른 설정이 적용되도록 하였습니다.<br><br>
    배포시에는 젠킨스와 같은 CI/CD 툴을 사용하여 배포를 자동화 할 것이며, 개발 서버와 배포 서버를 나누어 두 환경을 분리하도록 처리하였습니다.

## 이상으로

위와 같이 게시판 프로젝트를 하나 만드는 데에 어디까지 고려할 수 있는지에 대해 정리하였고,<br>
본 프로젝트는 이러한 사항들을 반영하여 작성된 결과물입니다.<br>

보시는바와 같이 게시판이라는 서비스는 기본적인 웹개발을 배운 모두가 손쉽게 개발이 가능한 서비스지만,<br>
그 안에서 고려해야 할 사항은 이처럼 적지 않으며,<br>

예를들어<br>

비동기 처리,<br>
확장성에 대한 구조적 준비,<br>
보안 처리<br>

와 같은 단순한 기능 구현 영역과는 별개의 필수적인 요소들을 고려하지 않는다면,<br>
확률적으로 별다른 문제가 일어나지 않을수도 있지만, 일단 문제가 발생한 이후에는<br>

데이터 무결성의 결함,<br>
서비스에 급작스러운 대량 유입이 일어났을 때의 기회비용의 발생,<br>
보안 취약점에 따른 정보 유출 혹은 치명적인 정보 조작<br>

등 적지 않은 대가를 치뤄야만 할 것입니다.<br>

반면, 위와 같은 지식을 갖추고 개발 실무에 적용할 경우,<br>
당장 개발 속도의 경우는 오히려 기능 구현에만 초점을 맞춘 신입 개발자보다 떨어질 수도 있겠지만,<br>

모듈화와 MSA 를 통한 코드 재활용으로 추후 영구적으로 개발 속도 상승의 효과를 불 수 있고,<br>
신기능 개발시 기존의 검증된 모듈을 조합하는 방식으로 보다 안정적으로 결과를 낼 수 있을 것이며,<br>
담당하던 개발자가 부재한 상황에서도 다른 모듈에는 별다른 타격을 입지 않고 리스크 관리를 할 수 있을 것입니다.

오늘날 기술력을 갖춘 많은 IT 기업들이 MSA 와 모듈화와 TDD 를 수행하는 이유가 이러한 상황을 실제로 경험하고,
그에 대한 해결 방식으로서 실증했기 때문이라고 저는 생각합니다.<br>

지금은 복잡하게 꼬여있는 스파게티 코드만을 방지하는 것을 넘어,<br>
스파게티 도메인을 방지하는 것을 고려해야만 하는 시대입니다.<br>

쉽게 말하자면, <br>
기업이 제공하는 서비스들이 상호 복잡하게 얽혀서, 하나의 서비스에 일어나는 사소한 문제 하나가,
예측 못한 다른 서비스에 예측 못한 불이익을 발생시키는 것을 막는다는 기존의 고급 기술이,<br>
이제는 상식이 되어가며, 기업 경쟁력을 넘어 기업 생존력으로 작용한다는 것이고,<br>

이러한 상황 속에서,<br>
단순한 기능구현을 넘어선 도메인 지식을 갖춘 백엔드 개발자야말로 뛰어난 기술력과, 기업 문화를 갖춘, 건실한 기업이 요구하는 인재상이라고 판단하였기에<br>
그러한 능력을 갖추기 위한 노력을 본 포트폴리오에 담고자 노력하였습니다.<br>

지금의 제 경험상 알 수 있는 부분을 넘어선 영역에 대해서 제가 놓친 부분 역시 존재할 수도 있으리라는 사고적 유연성은 항상 갖추고 있습니다.<br>

그렇지만 적어도 현재까지 제가 주관했던 모든 프로젝트들과 제가 책임지고 진행하였던 모든 경험에 빗대어 보았을 때에는 실무를 진행하기에 부족함이 없는 기술력을 갖추었으며,
이를 기반으로 현재도 보다 다양한 서비스를 설계하고 구현하고 진행하고 있다는 것을 마지막으로 본 프로젝트의 설명글을 마칩니다.